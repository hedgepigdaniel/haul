{"version":3,"sources":["../../src/server/createDeltaBundle.ts"],"names":["createDeltaBundle","source","deltaObject","pre","modules","post","Buffer","from","JSON","stringify"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEe,SAASA,iBAAT,CAA2BC,MAA3B,EAA2C;AAAA;AACxD;AACA;AACA,QAAMC,WAA8B,2BAAG;AACrC;AACA;AACA;AACA;AACAC,IAAAA,GAAG,EAAEF,MALgC;AAMrC;AACA;AACAG,IAAAA,OAAO,EAAE,CAAC,CAAC,CAAD,EAAI,EAAJ,CAAD,CAR4B;AASrCC,IAAAA,IAAI,EAAE;AAT+B,GAAH,CAApC;AAHwD;AAexD,SAAOC,MAAM,CAACC,IAAP,CAAYC,IAAI,CAACC,SAAL,CAAeP,WAAf,CAAZ,CAAP;AACD","sourcesContent":["// The delta format is implemented in com.facebook.react.devsupport.BundleDeltaClient\ntype DeltaModuleEntry = [number, string | null];\ntype DeltaModuleMap = DeltaModuleEntry[] | string;\ntype DeltaBundleObject = {\n  id?: string;\n  pre?: string;\n  modules?: DeltaModuleMap;\n  post?: string;\n};\n\n// The logic it uses is quite simple: the app keeps an initially empty copy of this data:\n//\n// ```\n// constructor() {\n//   this.id = null;\n//   this.pre = {};\n//   this.delta = {};\n//   this.post = {};\n// }\n// ```\n//\n// Whenever a reload is requested, it appends `&deltaBundleId=${id}` to the url if\n// `this.id` is set, and on receiving a result performs something like:\n//\n// ```\n// deltaToBundle(delta) {\n//   if ('id' in delta) this.id = delta.id;\n//   for (const name of ['pre', 'delta', 'post']) {\n//     if (name in delta) {\n//       for (const [id, content] of delta[name]) {\n//         if (content !== null) {\n//           this[name][id] = content;\n//         } else {\n//           delete this[name][id];\n//         }\n//       }\n//     }\n//   }\n//   return [\n//     ...Object.values(this.pre),\n//     ...Object.values(this.delta),\n//     ...Object.values(this.post),\n//   ].join('\\n');\n// }\n// ```\n//\n// Note in particular that the map type it uses is LinkedHashMap,\n// which preserves *initial* insertion order, but ideally your modules\n// don't have order dependencies other than pre before delta before post.\n//\n// As you might imagine, react native packager uses pre for polyfills and\n// the module system, and post for the entry calls to require() and the\n// source[Mapping]URL comment.\n//\n// After all that, though, it's clear the simplest implementation of\n// delta bundles is to simply have a one module bundle that contains\n// the entire source.\n//\n// I assume the idea is the react native bundler looks at the deltaBundleId\n// and a mapping of modules that have changed since that id so it knows\n// what to rebuild - a better version of deltas could track the webpack\n// asset and module hashes in the same way, but it would probably not help\n// that much unless network transfer time is the limiting factor?\n\nexport default function createDeltaBundle(source: string) {\n  // pre and post has to be declared, if not,\n  // app will crash when Android tries to write null to file\n  const deltaObject: DeltaBundleObject = {\n    // Put bundle in `pre` segment, so that the stack trace will be correct.\n    // RN when building bundle code from `pre`, `modules` and `post` will add `\\n` as a separator\n    // between them, which results in stacktrace incorrectly having +1 line offset. By putting bundle\n    // in `pre` we ensure that the generated bundle won't have any prefix.\n    pre: source,\n    // We still need to send some modules, otherwise RN will treat it as an empty delta bundle\n    // and won't read it.\n    modules: [[0, '']],\n    post: '',\n  };\n\n  return Buffer.from(JSON.stringify(deltaObject));\n}\n"],"file":"createDeltaBundle.js"}